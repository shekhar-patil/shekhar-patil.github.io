"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[6979],{511:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/worker-pool-pattern-d4e6b452e1e1cdd40d9024b11b80581f.jpg"},3290:e=>{e.exports=JSON.parse('{"permalink":"/blog/worker-pool-pattern","source":"@site/blog/2024-08-08-worker-pool-pattern/index.md","title":"Worker pool pattern in Golang","description":"What is worker pool pattern?","date":"2024-08-08T00:00:00.000Z","tags":[{"inline":false,"label":"Golang","permalink":"/blog/tags/golang","description":"Go is a statically typed, compiled high-level programming language designed at Google..."},{"inline":true,"label":"Design Pattern","permalink":"/blog/tags/design-pattern"},{"inline":true,"label":"Concurrency","permalink":"/blog/tags/concurrency"}],"readingTime":1.99,"hasTruncateMarker":true,"authors":[{"name":"Shekhar Patil","title":"Full stack developer.","url":"https://github.com/shekhar-patil","github":"shekhar-patil","linkedin":"https://www.linkedin.com/in/shekhar-patil-834462135/","imageURL":"https://avatars.githubusercontent.com/u/16961675?s=400&u=70e54719e239d1148c24bc8661a72ee9e59f420d&v=4","key":"shekhar-patil","page":null}],"frontMatter":{"slug":"worker-pool-pattern","title":"Worker pool pattern in Golang","authors":"shekhar-patil","tags":["golang","Design Pattern","Concurrency"],"image":"./worker-pool-pattern.jpg"},"unlisted":false,"prevItem":{"title":"Failing Google\u2019s Final Round\u200a\u2014\u200aWhat I Learned","permalink":"/blog/google-interview"},"nextItem":{"title":"How to create and use Rake task in ruby and use it in the Rails?","permalink":"/blog/rake-task-in-rails"}}')},5833:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/worker-pool-pattern-d4e6b452e1e1cdd40d9024b11b80581f.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},9276:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>p});var r=t(3290),o=t(4848),s=t(8453);const a={slug:"worker-pool-pattern",title:"Worker pool pattern in Golang",authors:"shekhar-patil",tags:["golang","Design Pattern","Concurrency"],image:"./worker-pool-pattern.jpg"},i=void 0,l={image:t(511).A,authorsImageUrls:[void 0]},p=[{value:"What is worker pool pattern?",id:"what-is-worker-pool-pattern",level:3},{value:"The basic flow of the worker pool pattern looks like this:",id:"the-basic-flow-of-the-worker-pool-pattern-looks-like-this",level:3},{value:"Here is the final code implementing the Worker Pool pattern:",id:"here-is-the-final-code-implementing-the-worker-pool-pattern",level:3}];function u(e){const n={code:"code",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"what-is-worker-pool-pattern",children:"What is worker pool pattern?"}),"\n",(0,o.jsx)(n.p,{children:"The Worker Pool pattern is a concurrency pattern in Go that allows you to manage and control the number of goroutines working on a set of tasks. This pattern is particularly useful when you have a large number of tasks to process and want to limit the number of concurrent goroutines to prevent excessive resource usage."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Worker pool pattern",src:t(5833).A+"",width:"837",height:"307"})}),"\n",(0,o.jsx)(n.h3,{id:"the-basic-flow-of-the-worker-pool-pattern-looks-like-this",children:"The basic flow of the worker pool pattern looks like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"package main\n\nfunc main() {\n    numJobs := 10\n    numWorkers := 3\n\n\n    // Create job and result channels\n\n    // Start the worker pool\n\n    // Submit jobs to workers\n\n    // Collect results\n\n    // Wait for all goroutines to finish\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"here-is-the-final-code-implementing-the-worker-pool-pattern",children:"Here is the final code implementing the Worker Pool pattern:"}),"\n",(0,o.jsx)(n.p,{children:"Collects results in a separate goroutine."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n)\n\ntype Job struct {\n    Id    int\n    Value int\n}\n\ntype Result struct {\n    JobId int\n    Value int\n}\n\ntype WorkerPool struct {\n    numJobs    int\n    numWorkers int\n    jobs       chan Job\n    results    chan Result\n    wg         sync.WaitGroup // WaitGroup to track all worker goroutines\n}\n\nfunc (wp *WorkerPool) StartWorker(id int) {\n    defer wp.wg.Done()\n\n    for job := range wp.jobs {\n        fmt.Printf("Job %d processed by worker %d\\n", job.Id, id)\n        wp.results <- Result{JobId: job.Id, Value: job.Value * 1}\n    }\n}\n\nfunc (wp *WorkerPool) StartWorkers() {\n    for i := 0; i < wp.numWorkers; i++ {\n        wp.wg.Add(1)\n        go wp.StartWorker(i)\n    }\n}\n\nfunc (wp *WorkerPool) SubmitJobs() {\n    for i := 0; i < wp.numJobs; i++ {\n        wp.jobs <- Job{Id: i, Value: i}\n    }\n    close(wp.jobs)\n}\n\nfunc (wp *WorkerPool) PrintResults(wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for result := range wp.results {\n        fmt.Printf("Result: Job %d Value %d\\n", result.JobId, result.Value)\n    }\n}\n\nfunc main() {\n    numJobs := 10\n    numWorkers := 3\n    var wg sync.WaitGroup // WaitGroup to track the results printer goroutine\n\n    // Initialize the WorkerPool with job and result channels\n    wp := WorkerPool{\n        numJobs:    numJobs,\n        numWorkers: numWorkers,\n        jobs:       make(chan Job, numJobs),\n        results:    make(chan Result, numJobs),\n    }\n\n    // Start workers\n    wp.StartWorkers()\n\n    // Submit jobs to the job channel\n    go func() {\n        wp.SubmitJobs()\n    }()\n\n    // Start the results printer goroutine\n    wg.Add(1)\n    go wp.PrintResults(&wg)\n\n    // Wait for all worker goroutines to complete\n    wp.wg.Wait()\n\n    // Close the results channel once all workers are done\n    close(wp.results)\n\n    // Wait for the results printer to finish\n    wg.Wait()\n}\n\n\n'})}),"\n",(0,o.jsx)(n.p,{children:"We use two separate WaitGroups in this pattern:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Worker WaitGroup"}),": Tracks when all worker goroutines have finished their tasks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Results WaitGroup"}),": Ensures the results printing goroutine completes its work after all results are processed."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This separation allows us to manage the lifecycle of workers and results printing independently, ensuring that all tasks are processed and printed correctly."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);