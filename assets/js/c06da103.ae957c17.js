"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[5517],{5049:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>s});var i=t(7745),o=t(4848),r=t(8453);const a={slug:"terminate-goroutines",title:"How to Terminate Goroutines in Go",authors:"shekhar-patil",tags:["golang","Design Pattern","Concurrency"]},c=void 0,l={authorsImageUrls:[void 0]},s=[{value:"How to Terminate Goroutines in Go?",id:"how-to-terminate-goroutines-in-go",level:3},{value:"Method 1: Using <code>context.Context</code>",id:"method-1-using-contextcontext",level:3},{value:"<code>context.WithTimeout(parent Context, timeout time.Duration)</code>",id:"contextwithtimeoutparent-context-timeout-timeduration",level:4},{value:"<code>context.WithDeadline(parent Context, deadline time.Time)</code>",id:"contextwithdeadlineparent-context-deadline-timetime",level:4},{value:"Method 2: Using Channels to Signal Termination",id:"method-2-using-channels-to-signal-termination",level:3},{value:"Method 3: Using a Shared Variable (Not Recommended)",id:"method-3-using-a-shared-variable-not-recommended",level:3},{value:"Conclusion",id:"conclusion",level:3}];function d(n){const e={code:"code",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"This week, I explored goroutines in more depth, particularly focusing on how to terminate them gracefully."}),"\n",(0,o.jsx)(e.h3,{id:"how-to-terminate-goroutines-in-go",children:"How to Terminate Goroutines in Go?"}),"\n",(0,o.jsxs)(e.p,{children:["In Go, goroutines cannot be forcefully killed. Instead, they should be terminated ",(0,o.jsx)(e.strong,{children:"gracefully and in a controlled manner"}),"."]}),"\n",(0,o.jsxs)(e.p,{children:["You can achieve this using mechanisms such as ",(0,o.jsx)(e.strong,{children:"channels"}),", ",(0,o.jsx)(e.strong,{children:"context"}),", or a ",(0,o.jsx)(e.strong,{children:"shared flag"}),". Among these, using ",(0,o.jsx)(e.code,{children:"context"})," is the most recommended and idiomatic way."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.h3,{id:"method-1-using-contextcontext",children:["Method 1: Using ",(0,o.jsx)(e.code,{children:"context.Context"})]}),"\n",(0,o.jsxs)(e.p,{children:["Use ",(0,o.jsx)(e.code,{children:"context.WithCancel"})," when you want to manually signal cancellation. When ",(0,o.jsx)(e.code,{children:"cancel()"})," is called, all goroutines observing that context will receive a signal via ",(0,o.jsx)(e.code,{children:"<-ctx.Done()"}),"."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n    "fmt"\n    "sync"\n    "time"\n)\n\nfunc worker(ctx context.Context, wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println("Worker cancelled:", ctx.Err())\n            return\n        default:\n            fmt.Println("Working...")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    var wg sync.WaitGroup\n\n    wg.Add(1)\n    go worker(ctx, &wg)\n\n    time.Sleep(2 * time.Second)\n    cancel()\n    wg.Wait()\n\n    fmt.Println("All workers done")\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.p,{children:"You can also use other context-based methods:"}),"\n",(0,o.jsx)(e.h4,{id:"contextwithtimeoutparent-context-timeout-timeduration",children:(0,o.jsx)(e.code,{children:"context.WithTimeout(parent Context, timeout time.Duration)"})}),"\n",(0,o.jsx)(e.p,{children:"This automatically cancels the context after the specified duration."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\ngo func(ctx context.Context) {\n    <-ctx.Done()\n    fmt.Println("Timed out:", ctx.Err()) // Prints after 2 seconds\n}(ctx)\n'})}),"\n",(0,o.jsx)(e.h4,{id:"contextwithdeadlineparent-context-deadline-timetime",children:(0,o.jsx)(e.code,{children:"context.WithDeadline(parent Context, deadline time.Time)"})}),"\n",(0,o.jsxs)(e.p,{children:["This cancels the context at a specific time. It's similar to ",(0,o.jsx)(e.code,{children:"WithTimeout"}),", but instead of a duration, you provide an exact deadline."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'deadline := time.Now().Add(3 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n\ngo func(ctx context.Context) {\n    <-ctx.Done()\n    fmt.Println("Deadline reached:", ctx.Err())\n}(ctx)\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"method-2-using-channels-to-signal-termination",children:"Method 2: Using Channels to Signal Termination"}),"\n",(0,o.jsx)(e.p,{children:"This is another clean and idiomatic approach in Go."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n    "time"\n)\n\nfunc worker(ch chan bool, wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for {\n        select {\n        case <-ch:\n            fmt.Println("Worker cancelled")\n            return\n        default:\n            fmt.Println("Working...")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    ch := make(chan bool)\n    var wg sync.WaitGroup\n\n    wg.Add(1)\n    go worker(ch, &wg)\n\n    time.Sleep(2 * time.Second)\n    ch <- true\n\n    wg.Wait()\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"method-3-using-a-shared-variable-not-recommended",children:"Method 3: Using a Shared Variable (Not Recommended)"}),"\n",(0,o.jsx)(e.p,{children:"While possible, this method is generally discouraged unless necessary, as it can be prone to race conditions if not handled properly."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n    "sync/atomic"\n    "time"\n)\n\nfunc worker(stop *int32, wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for {\n        if atomic.LoadInt32(stop) == 1 {\n            fmt.Println("Worker cancelled.")\n            return\n        }\n        fmt.Println("Working...")\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    var stop int32\n    var wg sync.WaitGroup\n\n    wg.Add(1)\n    go worker(&stop, &wg)\n\n    time.Sleep(2 * time.Second)\n    atomic.StoreInt32(&stop, 1)\n\n    wg.Wait()\n    fmt.Println("All workers done")\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(e.p,{children:"Graceful termination of goroutines is a fundamental part of writing robust concurrent code in Go. Use:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"context"})," for structured and scalable cancellation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"channels"})," for simple signaling"]}),"\n",(0,o.jsx)(e.li,{children:"shared flags with caution and proper synchronization"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["Each method has its own use case, but ",(0,o.jsx)(e.strong,{children:"context-based cancellation is the most idiomatic and scalable"})," approach in modern Go applications."]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},7745:n=>{n.exports=JSON.parse('{"permalink":"/blog/terminate-goroutines","source":"@site/blog/2025-05-30-terminate-goroutine/index.md","title":"How to Terminate Goroutines in Go","description":"This week, I explored goroutines in more depth, particularly focusing on how to terminate them gracefully.","date":"2025-05-30T00:00:00.000Z","tags":[{"inline":false,"label":"Golang","permalink":"/blog/tags/golang","description":"Go is a statically typed, compiled high-level programming language designed at Google..."},{"inline":true,"label":"Design Pattern","permalink":"/blog/tags/design-pattern"},{"inline":true,"label":"Concurrency","permalink":"/blog/tags/concurrency"}],"readingTime":2.26,"hasTruncateMarker":true,"authors":[{"name":"Shekhar Patil","title":"Full stack developer.","url":"https://github.com/shekhar-patil","github":"shekhar-patil","linkedin":"https://www.linkedin.com/in/shekhar-patil-834462135/","imageURL":"https://avatars.githubusercontent.com/u/16961675?s=400&u=70e54719e239d1148c24bc8661a72ee9e59f420d&v=4","key":"shekhar-patil","page":null}],"frontMatter":{"slug":"terminate-goroutines","title":"How to Terminate Goroutines in Go","authors":"shekhar-patil","tags":["golang","Design Pattern","Concurrency"]},"unlisted":false,"prevItem":{"title":"Migrating to Distroless Containers \u2014 My Real World Journey","permalink":"/blog/distroless-migration"},"nextItem":{"title":"Introducing My New Ruby Gem - PDFScanner","permalink":"/blog/scan-pdf-files-with-pdfscanner-gem"}}')},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var i=t(6540);const o={},r=i.createContext(o);function a(n){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);