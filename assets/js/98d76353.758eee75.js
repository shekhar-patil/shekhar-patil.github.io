"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[9986],{4047:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/stack-cb806a57a8e92be6064308e353ae6232.jpg"},5078:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/stack-cb806a57a8e92be6064308e353ae6232.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},9299:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"data-structures-and-algorithms/data-structures/stack/stack","title":"Stack in Golang","description":"A Stack is a Last In, First Out (LIFO) data structure, meaning that the most recently added element is the first one to be removed.","source":"@site/docs/data-structures-and-algorithms/data-structures/stack/stack.md","sourceDirName":"data-structures-and-algorithms/data-structures/stack","slug":"/data-structures-and-algorithms/data-structures/stack/","permalink":"/docs/data-structures-and-algorithms/data-structures/stack/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"image":"./img/stack.jpg"},"sidebar":"dsaSidebar","previous":{"title":"Stack Data Structure","permalink":"/docs/category/stack-data-structure"},"next":{"title":"Tree","permalink":"/docs/category/tree"}}');var a=n(4848),r=n(8453);const i={sidebar_position:1,image:"./img/stack.jpg"},c="Stack in Golang",o={image:n(4047).A},d=[];function m(e){const t={code:"code",h1:"h1",header:"header",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"stack-in-golang",children:"Stack in Golang"})}),"\n",(0,a.jsx)(t.p,{children:"A Stack is a Last In, First Out (LIFO) data structure, meaning that the most recently added element is the first one to be removed."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Stack",src:n(5078).A+"",width:"1200",height:"630"})}),"\n",(0,a.jsx)(t.p,{children:"I have implemented a stack in Golang using interfaces, which enhances its flexibility by allowing it to handle multiple data types. In Go, interfaces enable us to define methods without specifying the exact types. By leveraging this feature, I created a generic stack that can store elements of any type, from integers and strings to more complex data types like structs."}),"\n",(0,a.jsxs)(t.p,{children:["This approach eliminates the need for multiple stack implementations for different types. Instead, the interface based design abstracts the stack\u2019s functionality, ensuring type safety while maintaining reusability. The stack methods such as ",(0,a.jsx)(t.code,{children:"Push"}),", ",(0,a.jsx)(t.code,{children:"Pop"}),", and ",(0,a.jsx)(t.code,{children:"Peek"})," can be applied universally, providing a seamless and efficient solution for various use cases in Golang."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n    "errors"\n    "fmt"\n)\n\n// Stack defines the interface for stack operations using generics\ntype Stack[T any] interface {\n    Push(data T) error\n    Pop() (T, error)\n    Peek() (T, error)\n    IsEmpty() bool\n    Size() int\n}\n\n// GenericStack is a concrete implementation of a stack for any data type\ntype GenericStack[T any] struct {\n    items []T\n}\n\n// NewGenericStack creates and returns a new GenericStack\nfunc NewGenericStack[T any]() *GenericStack[T] {\n    return &GenericStack[T]{\n        items: []T{},\n    }\n}\n\n// Push adds an item to the top of the stack\nfunc (s *GenericStack[T]) Push(data T) error {\n    s.items = append(s.items, data)\n    fmt.Println("Item", data, "Pushed to stack")\n    return nil\n}\n\n// Pop removes and returns the top item from the stack\nfunc (s *GenericStack[T]) Pop() (T, error) {\n    if s.IsEmpty() {\n        var zeroValue T\n        return zeroValue, errors.New("pop failed: stack is empty")\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    fmt.Println("Popped item:", item)\n    return item, nil\n}\n\n// Peek returns the top item without removing it\nfunc (s *GenericStack[T]) Peek() (T, error) {\n    if s.IsEmpty() {\n        var zeroValue T\n        return zeroValue, errors.New("peek failed: stack is empty")\n    }\n    item := s.items[len(s.items)-1]\n    fmt.Println("Top item is:", item)\n    return item, nil\n}\n\n// IsEmpty checks if the stack is empty\nfunc (s *GenericStack[T]) IsEmpty() bool {\n    return len(s.items) == 0\n}\n\n// Size returns the number of items in the stack\nfunc (s *GenericStack[T]) Size() int {\n    return len(s.items)\n}\n\n// stackOperations demonstrates using the generic stack interface\nfunc stackOperations[T any](s Stack[T], data []T) {\n    // Pushing items\n    for _, item := range data {\n        if err := s.Push(item); err != nil {\n            fmt.Println("Error pushing to stack:", err)\n        }\n    }\n\n    // Displaying the top item\n    if _, err := s.Peek(); err != nil {\n        fmt.Println(err)\n    }\n\n    // Popping items\n    for i := 0; i < len(data); i++ {\n        if _, err := s.Pop(); err != nil {\n            fmt.Println(err)\n        }\n    }\n\n    // Attempt to pop from an empty stack\n    if _, err := s.Pop(); err != nil {\n        fmt.Println(err)\n    }\n}\n\nfunc main() {\n    // Create a new stack for integers\n    s := NewGenericStack[int]()\n    stackOperations(s, []int{10, 20, 30})\n\n    // Create a new stack for strings\n    strStack := NewGenericStack[string]()\n    stackOperations(strStack, []string{"hello", "world"})\n}\n\n\n'})}),"\n",(0,a.jsx)(t.p,{children:"Happy Coding!"})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);