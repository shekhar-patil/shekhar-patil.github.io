"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[2924],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},9765:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"data-structures-and-algorithms/sorting-algorithms/insertion-sort","title":"Insertion Sort","description":"Insertion Sort is a simple and intuitive comparison-based sorting algorithm. It builds the final sorted array one element at a time, by repeatedly picking the next element and inserting it into its correct position among the previously sorted elements.","source":"@site/docs/data-structures-and-algorithms/sorting-algorithms/insertion-sort.md","sourceDirName":"data-structures-and-algorithms/sorting-algorithms","slug":"/data-structures-and-algorithms/sorting-algorithms/insertion-sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/insertion-sort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"dsaSidebar","previous":{"title":"Bubble Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/bubble-sort"},"next":{"title":"Selection Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/selection-sort"}}');var i=t(4848),r=t(8453);const a={sidebar_position:3},o="Insertion Sort",l={},d=[{value:"\ud83e\udde0 Algorithm (Go Implementation)",id:"-algorithm-go-implementation",level:2},{value:"\ud83d\udcc8 Time and Space Complexity",id:"-time-and-space-complexity",level:2},{value:"\u2705 Advantages",id:"-advantages",level:2},{value:"\u274c Disadvantages",id:"-disadvantages",level:2},{value:"\ud83c\udf0d Real-Life Examples",id:"-real-life-examples",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"insertion-sort",children:"Insertion Sort"})}),"\n",(0,i.jsx)(n.p,{children:"Insertion Sort is a simple and intuitive comparison-based sorting algorithm. It builds the final sorted array one element at a time, by repeatedly picking the next element and inserting it into its correct position among the previously sorted elements."}),"\n",(0,i.jsx)(n.p,{children:"Though not suitable for large datasets due to its quadratic time complexity, Insertion Sort is efficient for small datasets and nearly sorted arrays."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-algorithm-go-implementation",children:"\ud83e\udde0 Algorithm (Go Implementation)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n  "fmt"\n)\n\nfunc insertionSort(nums []int) {\n  for i := 1; i < len(nums); i++ {\n    key := nums[i]\n    j := i - 1\n\n    for j >= 0 && nums[j] > key {\n      nums[j+1] = nums[j]\n      j--\n    }\n    nums[j+1] = key\n  }\n}\n\nfunc main() {\n  nums := []int{10, 2, 5, 3, 1}\n  insertionSort(nums)\n  fmt.Println(nums)\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-time-and-space-complexity",children:"\ud83d\udcc8 Time and Space Complexity"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Case"}),(0,i.jsx)(n.th,{children:"Time Complexity"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Best Case"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Average Case"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Worst Case"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best case"}),": When the array is already sorted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Worst case"}),": When the array is sorted in reverse."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1) \u2014 In-place sorting."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-advantages",children:"\u2705 Advantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simple and easy to implement."}),"\n",(0,i.jsx)(n.li,{children:"Efficient for small datasets."}),"\n",(0,i.jsx)(n.li,{children:"Performs well on nearly sorted arrays."}),"\n",(0,i.jsx)(n.li,{children:"Stable sort (maintains relative order of equal elements)."}),"\n",(0,i.jsx)(n.li,{children:"In-place sorting (no extra memory required)."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-disadvantages",children:"\u274c Disadvantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inefficient on large datasets."}),"\n",(0,i.jsx)(n.li,{children:"O(n\xb2) time complexity for worst-case and average-case scenarios."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-real-life-examples",children:"\ud83c\udf0d Real-Life Examples"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Sorting playing cards in your hand."}),"\n",(0,i.jsx)(n.li,{children:"Small datasets where simplicity is preferred."}),"\n",(0,i.jsx)(n.li,{children:"Useful in hybrid algorithms (e.g. Timsort)."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Feel free to follow my work on GitHub: ",(0,i.jsx)(n.a,{href:"https://github.com/shekhar-patil/data_structure_and_algorithms/blob/main/sorting_algorithms/insertion_sort.go",children:"Insertion Sort in Go"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);