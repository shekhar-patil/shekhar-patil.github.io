"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[209],{1216:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/doubly-linked-list-0a66fbe212f576b7847914c53306f66e.jpg"},7531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"data-structures-and-algorithms/data-structures/linked-list/doubly-linked-list","title":"Doubly Linked List","description":"A Doubly Linked List is a more sophisticated data structure compared to a Singly Linked List. In a Doubly Linked List, each node contains three fields: data, a pointer to the next node, and a pointer to the previous node. This structure allows for traversal in both directions\u2014from the head (the first node) to the tail (the last node), and vice versa.","source":"@site/docs/data-structures-and-algorithms/data-structures/linked-list/doubly-linked-list.md","sourceDirName":"data-structures-and-algorithms/data-structures/linked-list","slug":"/data-structures-and-algorithms/data-structures/linked-list/doubly-linked-list","permalink":"/docs/data-structures-and-algorithms/data-structures/linked-list/doubly-linked-list","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"dsaSidebar","previous":{"title":"Singly Linked List","permalink":"/docs/data-structures-and-algorithms/data-structures/linked-list/singly-linked-list"},"next":{"title":"Circular Linked List","permalink":"/docs/data-structures-and-algorithms/data-structures/linked-list/circular-linked-list"}}');var s=t(4848),d=t(8453);const o={sidebar_position:3},r="Doubly Linked List",a={},l=[{value:"Structure of a Doubly Linked List",id:"structure-of-a-doubly-linked-list",level:3},{value:"Basic Operations on a Doubly Linked List",id:"basic-operations-on-a-doubly-linked-list",level:3},{value:"Implementing the Operations",id:"implementing-the-operations",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"doubly-linked-list",children:"Doubly Linked List"})}),"\n",(0,s.jsx)(n.p,{children:"A Doubly Linked List is a more sophisticated data structure compared to a Singly Linked List. In a Doubly Linked List, each node contains three fields: data, a pointer to the next node, and a pointer to the previous node. This structure allows for traversal in both directions\u2014from the head (the first node) to the tail (the last node), and vice versa."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Doubly linked list",src:t(1216).A+"",width:"776",height:"124"})}),"\n",(0,s.jsx)(n.h3,{id:"structure-of-a-doubly-linked-list",children:"Structure of a Doubly Linked List"}),"\n",(0,s.jsx)(n.p,{children:"In Go, a Doubly Linked List is typically implemented using two structs: one to represent the individual nodes of the list and another to manage the list as a whole."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Node struct"}),"\nThe ",(0,s.jsx)(n.code,{children:"Node"})," struct holds the data and has two references: one (",(0,s.jsx)(n.code,{children:"next"}),") to the next node in the list and one (",(0,s.jsx)(n.code,{children:"prev"}),") to the previous node."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type Node struct {\n  data int\n  next *Node\n  prev *Node\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LinkedList struct"}),"\nThe ",(0,s.jsx)(n.code,{children:"LinkedList"})," struct manages the entire list and typically contains a reference to the head node."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type LinkedList struct {\n  head *Node\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"basic-operations-on-a-doubly-linked-list",children:"Basic Operations on a Doubly Linked List"}),"\n",(0,s.jsx)(n.p,{children:"To work with a Doubly Linked List, we need to define several essential operations such as inserting a node, deleting a node, and printing the list's contents. Below is an outline of these operations using pseudo-code in Go."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"package main\n\n// import necessary packages\n\ntype Node struct {\n  data int\n  next *Node\n  prev *Node\n}\n\ntype LinkedList struct {\n  head *Node\n}\n\nfunc (list *LinkedList) insertNode(data int) {\n  // Code to insert a node into the list\n}\n\nfunc (list *LinkedList) deleteNode(val int) {\n  // Code to delete a node from the list\n}\n\nfunc (list *LinkedList) printList() {\n  // Code to print all nodes in the list\n}\n\nfunc main(){\n  list := LinkedList{}\n\n  list.insertNode(10)\n  list.deleteNode(10)\n  list.insertNode(20)\n  list.insertNode(30)\n  list.printList()\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"implementing-the-operations",children:"Implementing the Operations"}),"\n",(0,s.jsxs)(n.p,{children:["Let's dive into the actual implementation of the ",(0,s.jsx)(n.code,{children:"insertNode"}),", ",(0,s.jsx)(n.code,{children:"deleteNode"}),", and ",(0,s.jsx)(n.code,{children:"printList"})," functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n  "fmt"\n  "strconv"\n)\n\n// Node represents an element in the doubly linked list\ntype Node struct {\n  data int\n  next *Node\n  prev *Node\n}\n\n// LinkedList represents the doubly linked list\ntype LinkedList struct {\n  head *Node\n}\n\n// Insert a new node at the end of the list\nfunc (l *LinkedList) insertNode(data int) {\n  // Create a new node with the provided data\n  node := &Node{data: data}\n\n  // If the list is empty, set the new node as the head\n  if l.head == nil {\n    l.head = node\n    return\n  }\n\n  // Traverse the list to find the last node\n  ptr := l.head\n  for ptr.next != nil {\n    ptr = ptr.next\n  }\n\n  // Set the new node as the next node of the last node and update the previous pointer of the new node\n  node.prev = ptr\n  ptr.next = node\n}\n\n// Delete a node by value from the list\nfunc (l *LinkedList) deleteNode(data int) {\n  // Check if the list is empty\n  if l.head == nil {\n    fmt.Println("List is empty")\n    return\n  }\n\n  // Pointer to traverse the list\n  ptr := l.head\n\n  // Check if the node to delete is the head node\n  if ptr.data == data {\n    l.head = ptr.next\n    if l.head != nil {\n      l.head.prev = nil // Update the previous pointer of the new head\n    }\n    return\n  }\n\n  // Traverse the list to find the node with the matching data\n  for ptr != nil && ptr.data != data {\n    ptr = ptr.next\n  }\n\n  // If the node was not found\n  if ptr == nil {\n    fmt.Println("Number not found")\n    return\n  }\n\n  // If the node to delete is the last node\n  if ptr.next == nil {\n    ptr.prev.next = nil\n  } else {\n    // If the node to delete is in the middle, update the pointers of the neighboring nodes\n    ptr.next.prev = ptr.prev\n    ptr.prev.next = ptr.next\n  }\n}\n\n// Print all nodes in the list\nfunc (l *LinkedList) printNodes() {\n  // Pointer to traverse the list\n  ptr := l.head\n  var list string\n\n  // Traverse and concatenate the data of each node to the list string\n  for ptr != nil {\n    list += strconv.Itoa(ptr.data) // Convert integer data to string and add to the list\n\n    // If not the last node, add an arrow to the string\n    if ptr.next != nil {\n      list += "---\x3e"\n    }\n    ptr = ptr.next\n  }\n\n  // Print the final concatenated string representing the linked list\n  fmt.Println(list)\n}\n\n// main function to demonstrate the linked list operations\nfunc main() {\n  // Create an empty linked list\n  l := LinkedList{}\n\n  // Insert nodes into the linked list\n  l.insertNode(1)\n  l.insertNode(2)\n  l.insertNode(3)\n  l.insertNode(4)\n\n  // Print the linked list\n  l.printNodes() // Output: 1---\x3e2---\x3e3---\x3e4\n\n  // Delete a node from the linked list\n  l.deleteNode(1)\n  l.printNodes() // Output: 2---\x3e3---\x3e4\n\n  // Try to delete a non-existent node\n  l.deleteNode(10) // Output: Number not found\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This Go code demonstrates how to manage a Doubly Linked List by inserting and deleting nodes, as well as printing the list\u2019s contents."}),"\n",(0,s.jsxs)(n.p,{children:["For a more detailed exploration and code examples, you can check out my work on GitHub: ",(0,s.jsx)(n.a,{href:"https://github.com/shekhar-patil/data_structure_and_algorithms/blob/main/data_structures/linked_list/golang/doubly_linked_list.go",children:"Doubly Linked List in Go"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},d=i.createContext(s);function o(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);