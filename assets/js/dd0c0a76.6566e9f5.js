"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[6870],{7622:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"data-structures-and-algorithms/sorting-algorithms/merge-sort","title":"Merge Sort","description":"Merge Sort is a highly efficient, comparison-based, divide-and-conquer sorting algorithm. It divides the array into halves, recursively sorts each half, and then merges the sorted halves back together.","source":"@site/docs/data-structures-and-algorithms/sorting-algorithms/merge-sort.md","sourceDirName":"data-structures-and-algorithms/sorting-algorithms","slug":"/data-structures-and-algorithms/sorting-algorithms/merge-sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/merge-sort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"dsaSidebar","previous":{"title":"Selection Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/selection-sort"},"next":{"title":"Quick Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/quick-sort"}}');var s=t(4848),i=t(8453);const a={sidebar_position:5},l="Merge Sort",o={},d=[{value:"\ud83e\udde0 Algorithm Explanation",id:"-algorithm-explanation",level:2},{value:"\ud83d\udcbb Go Implementation",id:"-go-implementation",level:2},{value:"\ud83d\udcc8 Time and Space Complexity",id:"-time-and-space-complexity",level:2},{value:"\u2705 Advantages",id:"-advantages",level:2},{value:"\u274c Disadvantages",id:"-disadvantages",level:2},{value:"\ud83c\udf0d Real-Life Examples",id:"-real-life-examples",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"merge-sort",children:"Merge Sort"})}),"\n",(0,s.jsx)(n.p,{children:"Merge Sort is a highly efficient, comparison-based, divide-and-conquer sorting algorithm. It divides the array into halves, recursively sorts each half, and then merges the sorted halves back together."}),"\n",(0,s.jsx)(n.p,{children:"Unlike simpler algorithms (Bubble, Insertion, Selection), Merge Sort offers significantly better performance on larger datasets due to its O(n log n) time complexity."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-algorithm-explanation",children:"\ud83e\udde0 Algorithm Explanation"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Divide the array into two halves."}),"\n",(0,s.jsx)(n.li,{children:"Recursively sort each half."}),"\n",(0,s.jsx)(n.li,{children:"Merge the two sorted halves into a single sorted array."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The key idea is that merging two sorted arrays can be done efficiently in linear time."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-go-implementation",children:"\ud83d\udcbb Go Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\n// Merge merges two sorted slices into a single sorted slice.\nfunc Merge(left []int, right []int) []int {\n    i := 0\n    j := 0\n    result := []int{}\n\n    for i < len(left) && j < len(right) {\n        if left[i] < right[j] {\n            result = append(result, left[i])\n            i++\n        } else {\n            result = append(result, right[j])\n            j++\n        }\n    }\n\n    // Append remaining elements (if any)\n    result = append(result, left[i:]...)\n    result = append(result, right[j:]...)\n\n    return result\n}\n\n// MergeSort performs merge sort on the input slice.\nfunc MergeSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n\n    mid := len(arr) / 2\n    left := MergeSort(arr[:mid])\n    right := MergeSort(arr[mid:])\n\n    return Merge(left, right)\n}\n\nfunc main() {\n    arr := []int{10, 2, 5, 3, 1, 7, 0}\n    fmt.Println(MergeSort(arr))\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-time-and-space-complexity",children:"\ud83d\udcc8 Time and Space Complexity"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Case"}),(0,s.jsx)(n.th,{children:"Time Complexity"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Best Case"}),(0,s.jsx)(n.td,{children:"O(n log n)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Average Case"}),(0,s.jsx)(n.td,{children:"O(n log n)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Worst Case"}),(0,s.jsx)(n.td,{children:"O(n log n)"})]})]})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Space Complexity:"})," O(n) (because extra space is needed for merging)."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-advantages",children:"\u2705 Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Consistent O(n log n) performance for all cases."}),"\n",(0,s.jsx)(n.li,{children:"Stable sort (maintains the relative order of equal elements)."}),"\n",(0,s.jsx)(n.li,{children:"Well-suited for sorting linked lists and external sorting (huge data sets)."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-disadvantages",children:"\u274c Disadvantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Requires additional memory (O(n) extra space)."}),"\n",(0,s.jsx)(n.li,{children:"Not in-place (unlike quick sort or heap sort)."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-real-life-examples",children:"\ud83c\udf0d Real-Life Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Large dataset sorting"})," (e.g. files, databases, external storage)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Linked lists sorting"})," (merge sort works very efficiently on linked lists)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel sorting"})," (merge sort divides naturally into independent tasks)."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Feel free to follow my work on GitHub: ",(0,s.jsx)(n.a,{href:"https://github.com/shekhar-patil/data_structure_and_algorithms/blob/main/sorting_algorithms/merge_sort.go",children:"Merge Sort in Go"})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);