"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[6853],{3309:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"golang/golang-concurrency-patterns/graceful-shutdown-pattern","title":"Graceful Shutdown Pattern","description":"Graceful shutdown is an important aspect of writing robust and reliable applications. In Go, this can be achieved using goroutines and channels. In this post, we will explore how to implement a graceful shutdown pattern using these constructs.","source":"@site/docs/golang/golang-concurrency-patterns/graceful-shutdown-pattern.md","sourceDirName":"golang/golang-concurrency-patterns","slug":"/golang/golang-concurrency-patterns/graceful-shutdown-pattern","permalink":"/docs/golang/golang-concurrency-patterns/graceful-shutdown-pattern","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"golangSidebar","previous":{"title":"Worker Pools","permalink":"/docs/golang/golang-concurrency-patterns/worker-pool-pattern"}}');var o=t(4848),r=t(8453);const s={sidebar_position:2},a="Graceful Shutdown Pattern",l={},c=[{value:"Example Code",id:"example-code",level:3},{value:"Explanation",id:"explanation",level:3},{value:"1. <strong>Function Definition:</strong>",id:"1-function-definition",level:4},{value:"2. <strong>Main Function:</strong>",id:"2-main-function",level:4},{value:"Key Points",id:"key-points",level:3},{value:"Conclusion",id:"conclusion",level:3}];function h(n){const e={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"graceful-shutdown-pattern",children:"Graceful Shutdown Pattern"})}),"\n",(0,o.jsx)(e.p,{children:"Graceful shutdown is an important aspect of writing robust and reliable applications. In Go, this can be achieved using goroutines and channels. In this post, we will explore how to implement a graceful shutdown pattern using these constructs."}),"\n",(0,o.jsx)(e.h3,{id:"example-code",children:"Example Code"}),"\n",(0,o.jsx)(e.p,{children:"Here's a simple example demonstrating the graceful shutdown pattern in Go:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\nfunc performTask(terminateChan <-chan bool) {\n    for {\n        select {\n        case <-terminateChan:\n            fmt.Println("Task terminated by channel")\n            return\n        default:\n            fmt.Println("Task is running")\n            time.Sleep(time.Second)\n        }\n    }\n}\n\nfunc main() {\n    terminateChan := make(chan bool)\n\n    go performTask(terminateChan)\n\n    time.Sleep(5 * time.Second)\n    terminateChan <- true\n    time.Sleep(time.Second)\n    fmt.Println("Main Goroutine exited")\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"explanation",children:"Explanation"}),"\n",(0,o.jsxs)(e.h4,{id:"1-function-definition",children:["1. ",(0,o.jsx)(e.strong,{children:"Function Definition:"})]}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"performTask"}),' function simulates a long-running task. It continuously prints "Task is running" every second. The function also listens on the ',(0,o.jsx)(e.code,{children:"terminateChan"})," channel to determine when to stop:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func performTask(terminateChan <-chan bool) {\n    for {\n        select {\n        case <-terminateChan:\n            fmt.Println("Task terminated by channel")\n            return\n        default:\n            fmt.Println("Task is running")\n            time.Sleep(time.Second)\n        }\n    }\n}\n'})}),"\n",(0,o.jsxs)(e.h4,{id:"2-main-function",children:["2. ",(0,o.jsx)(e.strong,{children:"Main Function:"})]}),"\n",(0,o.jsxs)(e.p,{children:["In the ",(0,o.jsx)(e.code,{children:"main"})," function, a ",(0,o.jsx)(e.code,{children:"terminateChan"})," channel is created to signal termination. The ",(0,o.jsx)(e.code,{children:"performTask"})," function is started as a goroutine:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func main() {\n    terminateChan := make(chan bool)\n\n    go performTask(terminateChan)\n\n    time.Sleep(5 * time.Second)\n    terminateChan <- true\n    time.Sleep(time.Second)\n    fmt.Println("Main Goroutine exited")\n}\n'})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["The program sleeps for 5 seconds to allow the ",(0,o.jsx)(e.code,{children:"performTask"})," goroutine to run."]}),"\n",(0,o.jsxs)(e.li,{children:["After 5 seconds, the main goroutine sends a ",(0,o.jsx)(e.code,{children:"true"})," value to the ",(0,o.jsx)(e.code,{children:"terminateChan"})," channel, signaling the ",(0,o.jsx)(e.code,{children:"performTask"})," goroutine to stop."]}),"\n",(0,o.jsxs)(e.li,{children:["The main goroutine then sleeps for an additional second to ensure the ",(0,o.jsx)(e.code,{children:"performTask"})," goroutine has enough time to print the termination message before the program exits."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"key-points",children:"Key Points"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Channel Communication:"}),"\nChannels are used to signal the goroutine to terminate. This ensures that the goroutine stops running gracefully."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Select Statement:"}),"\nThe ",(0,o.jsx)(e.code,{children:"select"})," statement is used to wait for a signal on the ",(0,o.jsx)(e.code,{children:"terminateChan"})," channel. If a signal is received, the goroutine prints a termination message and returns, stopping its execution."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Graceful Shutdown:"}),"\nThis pattern ensures that the goroutine has a chance to clean up or finish its work before stopping. This is especially important in applications that handle resources like files, network connections, or databases."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(e.p,{children:"Using the graceful shutdown pattern in Go ensures that your applications can stop their operations cleanly and reliably. By leveraging goroutines and channels, you can easily implement this pattern to manage the lifecycle of your concurrent tasks."})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(h,{...n})}):h(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(n){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);