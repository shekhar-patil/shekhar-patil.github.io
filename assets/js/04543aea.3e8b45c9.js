"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[3246],{8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},9029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"data-structures-and-algorithms/sorting-algorithms/selection-sort","title":"Selection Sort","description":"Selection Sort is a simple comparison-based sorting algorithm. It divides the input list into two parts: the sublist of items already sorted, which is built up from left to right, and the sublist of items remaining to be sorted.","source":"@site/docs/data-structures-and-algorithms/sorting-algorithms/selection-sort.md","sourceDirName":"data-structures-and-algorithms/sorting-algorithms","slug":"/data-structures-and-algorithms/sorting-algorithms/selection-sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/selection-sort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"dsaSidebar","previous":{"title":"Insertion Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/insertion-sort"},"next":{"title":"Merge Sort","permalink":"/docs/data-structures-and-algorithms/sorting-algorithms/merge-sort"}}');var i=t(4848),r=t(8453);const l={sidebar_position:4},o="Selection Sort",a={},d=[{value:"\ud83e\udde0 Algorithm Explanation",id:"-algorithm-explanation",level:2},{value:"\ud83d\udcbb Go Implementation",id:"-go-implementation",level:2},{value:"\ud83d\udcc8 Time and Space Complexity",id:"-time-and-space-complexity",level:2},{value:"\u2705 Advantages",id:"-advantages",level:2},{value:"\u274c Disadvantages",id:"-disadvantages",level:2},{value:"\ud83c\udf0d Real-Life Examples",id:"-real-life-examples",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"selection-sort",children:"Selection Sort"})}),"\n",(0,i.jsx)(n.p,{children:"Selection Sort is a simple comparison-based sorting algorithm. It divides the input list into two parts: the sublist of items already sorted, which is built up from left to right, and the sublist of items remaining to be sorted."}),"\n",(0,i.jsx)(n.p,{children:"In every iteration, the algorithm selects the smallest (or largest, depending on sorting order) element from the unsorted sublist and swaps it with the leftmost unsorted element, effectively growing the sorted list one element at a time."}),"\n",(0,i.jsx)(n.p,{children:"Though not efficient for large datasets, Selection Sort is easy to understand and works well for small lists or educational purposes."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-algorithm-explanation",children:"\ud83e\udde0 Algorithm Explanation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Start from index ",(0,i.jsx)(n.code,{children:"0"})," and assume it's the minimum."]}),"\n",(0,i.jsx)(n.li,{children:"Loop through the rest of the list to find the actual minimum element."}),"\n",(0,i.jsxs)(n.li,{children:["Swap the found minimum with the element at index ",(0,i.jsx)(n.code,{children:"i"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Move to the next index and repeat the process until the array is sorted."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-go-implementation",children:"\ud83d\udcbb Go Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n  "fmt"\n)\n\nfunc selectionSort(nums []int) {\n  n := len(nums)\n\n  for i := 0; i < n; i++ {\n    minIdx := i\n\n    for j := i + 1; j < n; j++ {\n      if nums[j] < nums[minIdx] {\n        minIdx = j\n      }\n    }\n\n    if minIdx != i {\n      nums[minIdx], nums[i] = nums[i], nums[minIdx]\n    }\n  }\n}\n\nfunc main() {\n  nums := []int{5, 6, 3, 8, 2, 1}\n  selectionSort(nums)\n  fmt.Println(nums)\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-time-and-space-complexity",children:"\ud83d\udcc8 Time and Space Complexity"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Case"}),(0,i.jsx)(n.th,{children:"Time Complexity"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Best Case"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Average Case"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Worst Case"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best case and worst case have same complexity"}),", since selection sort always scans the unsorted part fully."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1) \u2014 In-place sorting."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-advantages",children:"\u2705 Advantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Very simple and easy to understand."}),"\n",(0,i.jsx)(n.li,{children:"Performs well on small datasets."}),"\n",(0,i.jsx)(n.li,{children:"In-place sorting (no extra memory required)."}),"\n",(0,i.jsxs)(n.li,{children:["Number of swaps is minimal (maximum ",(0,i.jsx)(n.code,{children:"n - 1"})," swaps)."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-disadvantages",children:"\u274c Disadvantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inefficient for large datasets."}),"\n",(0,i.jsx)(n.li,{children:"O(n\xb2) time complexity even for already sorted data."}),"\n",(0,i.jsxs)(n.li,{children:["Comparisons are always ",(0,i.jsx)(n.code,{children:"n(n-1)/2"})," \u2014 no early exit optimization."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-real-life-examples",children:"\ud83c\udf0d Real-Life Examples"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Classroom sorting of physical objects"})," (e.g. arranging weights, numbers, or cards manually)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Small embedded systems"})," where simplicity is preferred over speed."]}),"\n",(0,i.jsx)(n.li,{children:"Educational purposes for teaching sorting algorithms."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Feel free to follow my work on GitHub: ",(0,i.jsx)(n.a,{href:"https://github.com/shekhar-patil/data_structure_and_algorithms/blob/main/sorting_algorithms/selection_sort.go",children:"Selection Sort in Go"})]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);