"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[60],{228:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>i,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"golang/golang-concurrency/goroutines","title":"Goroutines","description":"\ud83d\ude80 Goroutines: Go\'s Lightweight Concurrency","source":"@site/docs/golang/golang-concurrency/goroutines.md","sourceDirName":"golang/golang-concurrency","slug":"/golang/golang-concurrency/goroutines","permalink":"/docs/golang/golang-concurrency/goroutines","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"golangSidebar","previous":{"title":"Go - Concurrency","permalink":"/docs/category/go---concurrency"},"next":{"title":"Channels","permalink":"/docs/golang/golang-concurrency/channels"}}');var s=t(4848),o=t(8453);const i={sidebar_position:1},l="Goroutines",c={},h=[{value:"\ud83d\ude80 Goroutines: Go&#39;s Lightweight Concurrency",id:"-goroutines-gos-lightweight-concurrency",level:2},{value:"Creating a Goroutine",id:"creating-a-goroutine",level:3},{value:"\ud83d\udca1 Why Goroutines Are Better Than OS Threads",id:"-why-goroutines-are-better-than-os-threads",level:2},{value:"\u2699\ufe0f How Goroutines Work: The G-M-P Scheduler Model",id:"\ufe0f-how-goroutines-work-the-g-m-p-scheduler-model",level:2},{value:"The Components",id:"the-components",level:3},{value:"The Execution Flow",id:"the-execution-flow",level:3},{value:"Communication and Synchronization",id:"communication-and-synchronization",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"goroutines",children:"Goroutines"})}),"\n",(0,s.jsx)(n.h2,{id:"-goroutines-gos-lightweight-concurrency",children:"\ud83d\ude80 Goroutines: Go's Lightweight Concurrency"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"Goroutine"})," is a lightweight, independent function execution managed by the Go runtime. Think of it as a function running concurrently with other code. It's Go's solution for simple and efficient concurrent programming."]}),"\n",(0,s.jsxs)(n.p,{children:["You create a Goroutine simply by using the ",(0,s.jsx)(n.code,{children:"go"})," keyword before a function call:"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-goroutine",children:"Creating a Goroutine"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'go func() {\n    // perform a concurrent operation\n    fmt.Println("This runs in a separate Goroutine!")\n}()\n\n// Or, for a regular function call:\nfunc myTask() { /* ... */ }\ngo myTask()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"-why-goroutines-are-better-than-os-threads",children:"\ud83d\udca1 Why Goroutines Are Better Than OS Threads"}),"\n",(0,s.jsxs)(n.p,{children:["Traditional ",(0,s.jsx)(n.strong,{children:"Operating System (OS) Threads"})," are expensive and resource-heavy. Go replaces them with Goroutines to achieve massive concurrency."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Feature"}),(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"Goroutine"})," (Go Runtime Managed)"]}),(0,s.jsxs)(n.th,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"OS Thread"})," (Kernel Managed)"]})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Initial Stack Size"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"~2 KB (tiny)"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"~1\u20138 MB (large)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Stack Growth"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Grows and shrinks ",(0,s.jsx)(n.strong,{children:"automatically"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Fixed size"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Creation Cost"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Very ",(0,s.jsx)(n.strong,{children:"cheap"})," and fast"]}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"Expensive"})," and slow"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Scheduling"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,s.jsx)(n.strong,{children:"User-space"})," (managed by Go runtime)"]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Kernel-space"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Count"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Can run ",(0,s.jsx)(n.strong,{children:"millions"})," easily"]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Limited to thousands"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Because of their minimal overhead, Go can efficiently run hundreds of thousands of Goroutines, a feat impossible with OS threads."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-how-goroutines-work-the-g-m-p-scheduler-model",children:"\u2699\ufe0f How Goroutines Work: The G-M-P Scheduler Model"}),"\n",(0,s.jsxs)(n.p,{children:["The Go runtime uses a sophisticated scheduler based on the ",(0,s.jsx)(n.strong,{children:"G-M-P model"})," to manage and execute Goroutines. This model maps many Goroutines onto a smaller number of OS threads."]}),"\n",(0,s.jsx)(n.h3,{id:"the-components",children:"The Components"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"G \u2014 Goroutine:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Represents an individual Goroutine."}),"\n",(0,s.jsxs)(n.li,{children:["It is a struct containing essential information like the ",(0,s.jsx)(n.strong,{children:"stack"}),", ",(0,s.jsx)(n.strong,{children:"instruction pointer"})," (where to resume execution), and ",(0,s.jsx)(n.strong,{children:"status"})," (e.g., runnable, waiting)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"M \u2014 Machine (OS Thread):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Represents an actual ",(0,s.jsx)(n.strong,{children:"OS thread"})," created by the kernel."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"M"})," executes the Go code."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"P \u2014 Processor (Logical CPU Resource):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"scheduler token"})," or context that allows an ",(0,s.jsx)(n.code,{children:"M"})," to execute Go code."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"P"})," ensures that only one ",(0,s.jsx)(n.code,{children:"M"})," executes Go code at any given time."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-execution-flow",children:"The Execution Flow"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"Goroutine (G)"})," is scheduled to run."]}),"\n",(0,s.jsxs)(n.li,{children:["It runs on an ",(0,s.jsx)(n.strong,{children:"Machine (M)"}),", which is an OS thread."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"M"})," must hold a ",(0,s.jsx)(n.strong,{children:"Processor (P)"})," to execute the Go code associated with the ",(0,s.jsx)(n.code,{children:"G"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The number of available ",(0,s.jsx)(n.strong,{children:"P"}),"s is controlled by the environment variable ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"GOMAXPROCS"})}),". This setting determines how many Goroutines can truly run ",(0,s.jsx)(n.strong,{children:"simultaneously"})," (in parallel). If there are more ready Goroutines than available ",(0,s.jsx)(n.strong,{children:"P"}),"s, the excess Goroutines wait in local or global run queues."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"communication-and-synchronization",children:"Communication and Synchronization"}),"\n",(0,s.jsxs)(n.p,{children:["Goroutines communicate with each other primarily using ",(0,s.jsx)(n.a,{href:"/docs/golang/golang-concurrency/channels",children:(0,s.jsx)(n.strong,{children:"channels"})}),". Channels provide a simple, safe way to pass data between concurrently executing functions, following Go's philosophy: ",(0,s.jsx)(n.strong,{children:'"Do not communicate by sharing memory; instead, share memory by communicating."'})]}),"\n",(0,s.jsx)(n.hr,{})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);