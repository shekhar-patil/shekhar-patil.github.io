"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[2221],{384:e=>{e.exports=JSON.parse('{"permalink":"/blog/eager-loading-and-N-plus-1-query","source":"@site/blog/2019-05-10-eager-loading-and-n-plus-1-query.md","title":"Eager loading and N+1 query in rails.","description":"Sometimes, the implementation of an algorithm can make performance worst. Then it does not matter whether it has used the faster programming language like C or slower like Ruby. So we should implement the algorithms properly. Same while dealing with the database we should use proper queries so that the performance should not affect.","date":"2019-05-10T00:00:00.000Z","tags":[{"inline":false,"label":"Rails","permalink":"/blog/tags/rails","description":"Ruby on Rails is a server-side web application framework..."},{"inline":false,"label":"Ruby","permalink":"/blog/tags/ruby","description":"A dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write."}],"readingTime":2.91,"hasTruncateMarker":true,"authors":[{"name":"Shekhar Patil","title":"Full stack developer.","url":"https://github.com/shekhar-patil","github":"shekhar-patil","linkedin":"https://www.linkedin.com/in/shekhar-patil-834462135/","imageURL":"https://avatars.githubusercontent.com/u/16961675?s=400&u=70e54719e239d1148c24bc8661a72ee9e59f420d&v=4","key":"shekhar-patil","page":null}],"frontMatter":{"slug":"eager-loading-and-N-plus-1-query","title":"Eager loading and N+1 query in rails.","authors":"shekhar-patil","tags":["rails","ruby"]},"unlisted":false,"prevItem":{"title":"Relational database.","permalink":"/blog/relational-database"},"nextItem":{"title":"First Blog Post","permalink":"/blog/first-blog-post"}}')},5249:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var l=t(384),s=t(4848),a=t(8453);const o={slug:"eager-loading-and-N-plus-1-query",title:"Eager loading and N+1 query in rails.",authors:"shekhar-patil",tags:["rails","ruby"]},i=void 0,r={authorsImageUrls:[void 0]},d=[{value:"Let&#39;s observe an example.",id:"lets-observe-an-example",level:3},{value:"N+1 query in Rails",id:"n1-query-in-rails",level:2},{value:"Eager loading in Rails",id:"eager-loading-in-rails",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Sometimes, the implementation of an algorithm can make performance worst. Then it does not matter whether it has used the faster programming language like C or slower like Ruby. So we should implement the algorithms properly. Same while dealing with the database we should use proper queries so that the performance should not affect."}),"\n",(0,s.jsx)(n.h3,{id:"lets-observe-an-example",children:"Let's observe an example."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"class College < ApplicationRecord\n  has_many :students\nend\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"class Student < ApplicationRecord\n  belongs_to :college\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now create some colleges and respective students."}),"\n",(0,s.jsx)(n.h2,{id:"n1-query-in-rails",children:"N+1 query in Rails"}),"\n",(0,s.jsx)(n.p,{children:"If we wanted to list the first ten students and their colleges, We could write the following code."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'students = Student.limit(10)\n\nstudents.each do |student|\n  puts "#{student.college.name} build number #{student.name}"\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:"The above code works, but it makes far too many independent database queries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'Student Load (0.3ms) SELECT "students".* FROM "students" LIMIT ? [["LIMIT", 10]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 1], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 2], ["LIMIT", 1]]\nCollege Load (0.1ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 2], ["LIMIT", 1]]\nCollege Load (0.2ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 2], ["LIMIT", 1]]\nCollege Load (0.1ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" = ? LIMIT ? [["id", 2], ["LIMIT", 1]]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Currently, There are 11 independent queries to fetch 10 students. One query to fetch students and other N queries to fetch college in each iteration. hence the total number of queries is N+1. Now are fetching just 10 records but in the real-time scenario, the number of required records can be large. Suppose we want to fetch 10000 records then we'll need to connect database 10001 times and it will degrade the performance of the application heavily."}),"\n",(0,s.jsx)(n.h2,{id:"eager-loading-in-rails",children:"Eager loading in Rails"}),"\n",(0,s.jsx)(n.p,{children:"To avoid the performance degradation of the previous example we need to reduce the number of independent queries to the database. In rails, this is done by eager loading associated relations. In the eager loading, we collect the required data with only one query."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'students = Student.includes(:college).limit(10)\n\nstudents.each do |student|\n  puts "#{student.college.name} build number #{student.name}"\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:"This time we'll use one query to fetch the students and another for fetching the associated colleges."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'Student Load (0.4ms) SELECT "students".* FROM "students"\nCollege Load (0.4ms) SELECT "colleges".* FROM "colleges" WHERE "colleges"."id" IN (?, ?, ?, ?) [["id", 1], ["id", 2], ["id", 3], ["id", 4]]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, we'll required only two queries. Even though we wanted 10000 records only two queries are required to fetch the records from the database and it will improve the performance of our application."}),"\n",(0,s.jsx)(n.p,{children:"For comparison, the time necessary to load and display 10 builds in my system is 2.1 milliseconds without eager loading and only 0.8 milliseconds with eager loading. This is s huge difference. Currently, In the case of a large number of record fetching, this time difference can be even far more."}),"\n",(0,s.jsxs)(n.p,{children:["I would love to hear some of your tips on dealing with N+1 queries on ",(0,s.jsx)(n.a,{href:"https://twitter.com/Shekharpatil95",children:"twitter"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Cheers!"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var l=t(6540);const s={},a=l.createContext(s);function o(e){const n=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);