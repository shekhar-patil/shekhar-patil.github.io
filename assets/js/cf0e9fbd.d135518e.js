"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[330],{6852:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"golang/golang-concurrency-patterns/worker-pool-pattern","title":"Worker Pools","description":"What is worker pool pattern?","source":"@site/docs/golang/golang-concurrency-patterns/worker-pool-pattern.md","sourceDirName":"golang/golang-concurrency-patterns","slug":"/golang/golang-concurrency-patterns/worker-pool-pattern","permalink":"/docs/golang/golang-concurrency-patterns/worker-pool-pattern","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"golangSidebar","previous":{"title":"Go - Concurrency Patterns","permalink":"/docs/category/go---concurrency-patterns"},"next":{"title":"Graceful Shutdown Pattern","permalink":"/docs/golang/golang-concurrency-patterns/graceful-shutdown-pattern"}}');var t=o(4848),s=o(8453);const a={sidebar_position:1},l="Worker Pools",i={},c=[{value:"What is worker pool pattern?",id:"what-is-worker-pool-pattern",level:3},{value:"The basic flow of the worker pool pattern looks like this:",id:"the-basic-flow-of-the-worker-pool-pattern-looks-like-this",level:3},{value:"Here is the final code implementing the Worker Pool pattern:",id:"here-is-the-final-code-implementing-the-worker-pool-pattern",level:3}];function p(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"worker-pools",children:"Worker Pools"})}),"\n",(0,t.jsx)(n.h3,{id:"what-is-worker-pool-pattern",children:"What is worker pool pattern?"}),"\n",(0,t.jsx)(n.p,{children:"The Worker Pool pattern is a concurrency pattern in Go that allows you to manage and control the number of goroutines working on a set of tasks. This pattern is particularly useful when you have a large number of tasks to process and want to limit the number of concurrent goroutines to prevent excessive resource usage."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Worker pool pattern",src:o(7436).A+"",width:"837",height:"307"})}),"\n",(0,t.jsx)(n.h3,{id:"the-basic-flow-of-the-worker-pool-pattern-looks-like-this",children:"The basic flow of the worker pool pattern looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"package main\n\nfunc main() {\n    numJobs := 10\n    numWorkers := 3\n\n\n    // Create job and result channels\n    \n    // Start the worker pool\n\n    // Submit jobs to workers\n\n    // Collect results\n\n    // Wait for all goroutines to finish\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"here-is-the-final-code-implementing-the-worker-pool-pattern",children:"Here is the final code implementing the Worker Pool pattern:"}),"\n",(0,t.jsx)(n.p,{children:"Collects results in a separate goroutine."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n)\n\ntype Job struct {\n    Id    int\n    Value int\n}\n\ntype Result struct {\n    JobId int\n    Value int\n}\n\ntype WorkerPool struct {\n    numJobs    int\n    numWorkers int\n    jobs       chan Job\n    results    chan Result\n    wg         sync.WaitGroup // WaitGroup to track all worker goroutines\n}\n\nfunc (wp *WorkerPool) StartWorker(id int) {\n    defer wp.wg.Done()\n\n    for job := range wp.jobs {\n        fmt.Printf("Job %d processed by worker %d\\n", job.Id, id)\n        wp.results <- Result{JobId: job.Id, Value: job.Value * 1}\n    }\n}\n\nfunc (wp *WorkerPool) StartWorkers() {\n    for i := 0; i < wp.numWorkers; i++ {\n        wp.wg.Add(1)\n        go wp.StartWorker(i)\n    }\n}\n\nfunc (wp *WorkerPool) SubmitJobs() {\n    for i := 0; i < wp.numJobs; i++ {\n        wp.jobs <- Job{Id: i, Value: i}\n    }\n    close(wp.jobs)\n}\n\nfunc (wp *WorkerPool) PrintResults(wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for result := range wp.results {\n        fmt.Printf("Result: Job %d Value %d\\n", result.JobId, result.Value)\n    }\n}\n\nfunc main() {\n    numJobs := 10\n    numWorkers := 3\n    var wg sync.WaitGroup // WaitGroup to track the results printer goroutine\n\n    // Initialize the WorkerPool with job and result channels\n    wp := WorkerPool{\n        numJobs:    numJobs,\n        numWorkers: numWorkers,\n        jobs:       make(chan Job, numJobs),\n        results:    make(chan Result, numJobs),\n    }\n\n    // Start workers\n    wp.StartWorkers()\n\n    // Submit jobs to the job channel\n    go func() {\n        wp.SubmitJobs()\n    }()\n\n    // Start the results printer goroutine\n    wg.Add(1)\n    go wp.PrintResults(&wg)\n\n    // Wait for all worker goroutines to complete\n    wp.wg.Wait()\n\n    // Close the results channel once all workers are done\n    close(wp.results)\n\n    // Wait for the results printer to finish\n    wg.Wait()\n}\n\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"We use two separate WaitGroups in this pattern:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker WaitGroup"}),": Tracks when all worker goroutines have finished their tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Results WaitGroup"}),": Ensures the results printing goroutine completes its work after all results are processed."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This separation allows us to manage the lifecycle of workers and results printing independently, ensuring that all tasks are processed and printed correctly."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},7436:(e,n,o)=>{o.d(n,{A:()=>r});const r=o.p+"assets/images/worker-pool-pattern-d4e6b452e1e1cdd40d9024b11b80581f.jpg"},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>l});var r=o(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);