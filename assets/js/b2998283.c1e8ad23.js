"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[6092],{755:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"data-structures-and-algorithms/data-structures/tree/binary-search-tree","title":"Binary Search Tree","description":"","source":"@site/docs/data-structures-and-algorithms/data-structures/tree/binary-search-tree.md","sourceDirName":"data-structures-and-algorithms/data-structures/tree","slug":"/data-structures-and-algorithms/data-structures/tree/binary-search-tree","permalink":"/docs/data-structures-and-algorithms/data-structures/tree/binary-search-tree","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"dsaSidebar","previous":{"title":"General Tree","permalink":"/docs/data-structures-and-algorithms/data-structures/tree/general-tree"},"next":{"title":"Sorting Algorithms","permalink":"/docs/category/sorting-algorithms"}}');var a=r(4848),i=r(8453);const s={sidebar_position:2},o="Binary Search Tree",u={},l=[];function c(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"binary-search-tree",children:"Binary Search Tree"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'\npackage main\n\nimport (\n    "errors"\n    "fmt"\n)\n\ntype Node struct {\n    key   int\n    value string\n    right *Node\n    left  *Node\n}\n\nfunc (n *Node) insert(key int, value string) {\n    if n.key > key {\n        if n.left == nil {\n            n.left = &Node{key: key, value: value}\n        } else {\n            n.left.insert(key, value)\n        }\n    } else if n.key < key {\n        if n.right == nil {\n            n.right = &Node{key: key, value: value}\n        } else {\n            n.right.insert(key, value)\n        }\n    }\n}\n\nfunc (n *Node) inOrderPrint() {\n    if n.left != nil {\n        n.left.inOrderPrint()\n    }\n\n    fmt.Println("Key: ", n.key, ", Value: ", n.value)\n\n    if n.right != nil {\n        n.right.inOrderPrint()\n    }\n}\n\nfunc (n *Node) searchValue(key int) (string, error) {\n    if n == nil {\n        return "", errors.New("Key not found")\n    }\n\n    if n.key == key {\n        return n.value, nil\n    }\n\n    if key > n.key {\n        if n.right == nil {\n            return "", errors.New("Key not found")\n        }\n        return n.right.searchValue(key)\n    } else {\n        if n.left == nil {\n            return "", errors.New("Key not found")\n        }\n        return n.left.searchValue(key)\n    }\n}\n\nfunc main() {\n    root := &Node{key: 10, value: "Mumbai"}\n\n    root.insert(5, "Delhi")\n    root.insert(2, "Kolkata")\n    root.insert(3, "Pune")\n    root.insert(9, "Nagpur")\n    root.insert(13, "Bengaluru")\n    root.insert(1, "Chennai")\n\n    root.inOrderPrint()\n\n    value, err := root.searchValue(20)\n\n    if err == nil {\n        fmt.Println("Key found, Value is: ", value)\n    } else {\n        fmt.Println(err)\n    }\n}\n\n'})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);