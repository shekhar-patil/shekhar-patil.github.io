"use strict";(self.webpackChunkshekhar_patil_github_io=self.webpackChunkshekhar_patil_github_io||[]).push([[1634],{6581:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"data-structures-and-algorithms/graph-algorithms/prims-algorithm","title":"Prim\u2019s Algorithm \u2014 Minimum Spanning Tree (MST)","description":"In this post, we will explore Prim\u2019s Algorithm, a greedy approach used to find the Minimum Spanning Tree (MST) of a weighted, undirected graph. We\u2019ll also implement the algorithm in Go and walk through a visual example to solidify your understanding.","source":"@site/docs/data-structures-and-algorithms/graph-algorithms/prims-algorithm.md","sourceDirName":"data-structures-and-algorithms/graph-algorithms","slug":"/data-structures-and-algorithms/graph-algorithms/prims-algorithm","permalink":"/docs/data-structures-and-algorithms/graph-algorithms/prims-algorithm","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"dsaSidebar","previous":{"title":"Graph Algorithms","permalink":"/docs/category/graph-algorithms"},"next":{"title":"Dijkstra\'s Algorithm","permalink":"/docs/data-structures-and-algorithms/graph-algorithms/dijkstra-algorithm"}}');var t=i(4848),r=i(8453);const l={sidebar_position:1},a="Prim\u2019s Algorithm \u2014 Minimum Spanning Tree (MST)",h={},o=[{value:"When Can We Use Prim\u2019s Algorithm?",id:"when-can-we-use-prims-algorithm",level:2},{value:"What Does It Do?",id:"what-does-it-do",level:2},{value:"Where Is It Used in Real Life?",id:"where-is-it-used-in-real-life",level:2},{value:"Example (With Visualization)",id:"example-with-visualization",level:2},{value:"\ud83d\udee0\ufe0f Go Implementation",id:"\ufe0f-go-implementation",level:2},{value:"Sample Input",id:"sample-input",level:2},{value:"Output",id:"output",level:3},{value:"\u23f1\ufe0f Time &amp; Space Complexity",id:"\ufe0f-time--space-complexity",level:2},{value:"\ud83d\udc4d Advantages",id:"-advantages",level:2},{value:"\ud83d\udc4e Disadvantages",id:"-disadvantages",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"prims-algorithm--minimum-spanning-tree-mst",children:"Prim\u2019s Algorithm \u2014 Minimum Spanning Tree (MST)"})}),"\n",(0,t.jsxs)(e.p,{children:["In this post, we will explore ",(0,t.jsx)(e.strong,{children:"Prim\u2019s Algorithm"}),", a greedy approach used to find the ",(0,t.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Minimum_spanning_tree",children:(0,t.jsx)(e.strong,{children:"Minimum Spanning Tree (MST)"})})," of a weighted, undirected graph. We\u2019ll also implement the algorithm in ",(0,t.jsx)(e.strong,{children:"Go"})," and walk through a visual example to solidify your understanding."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"when-can-we-use-prims-algorithm",children:"When Can We Use Prim\u2019s Algorithm?"}),"\n",(0,t.jsxs)(e.p,{children:["Prim\u2019s Algorithm can be applied ",(0,t.jsx)(e.strong,{children:"only when"})," the graph satisfies the following conditions:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["The graph is ",(0,t.jsx)(e.strong,{children:"undirected"})]}),"\n",(0,t.jsxs)(e.li,{children:["All edge weights are ",(0,t.jsx)(e.strong,{children:"non-negative"})]}),"\n",(0,t.jsxs)(e.li,{children:["The graph is ",(0,t.jsx)(e.strong,{children:"connected"})," (there's a path between every pair of nodes)"]}),"\n"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["\u2757 If the graph is ",(0,t.jsx)(e.strong,{children:"disconnected"}),", Prim\u2019s algorithm will not generate a spanning tree that includes all vertices."]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"what-does-it-do",children:"What Does It Do?"}),"\n",(0,t.jsxs)(e.p,{children:["Prim\u2019s Algorithm helps us find the ",(0,t.jsx)(e.strong,{children:"Minimum Spanning Tree (MST)"})," \u2014 a subset of the edges that:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Connects ",(0,t.jsx)(e.strong,{children:"all vertices"})," in the graph"]}),"\n",(0,t.jsxs)(e.li,{children:["Has ",(0,t.jsx)(e.strong,{children:"no cycles"})]}),"\n",(0,t.jsxs)(e.li,{children:["Has the ",(0,t.jsx)(e.strong,{children:"minimum total edge weight"})," possible"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"where-is-it-used-in-real-life",children:"Where Is It Used in Real Life?"}),"\n",(0,t.jsx)(e.p,{children:"Prim\u2019s Algorithm is widely used in various domains:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Designing road and highway networks"})," (connecting cities with minimal cost)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Laying out cables or pipelines"})," (least amount of wire or pipe needed to connect buildings)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Network design"})," (connecting routers/switches efficiently)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Cluster analysis in machine learning"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Utility planning"})," (electricity, water supply, etc.)"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"example-with-visualization",children:"Example (With Visualization)"}),"\n",(0,t.jsx)(e.p,{children:"Here\u2019s a visual explanation of Prim\u2019s Algorithm:"}),"\n",(0,t.jsx)("p",{align:"center",children:(0,t.jsx)("img",{src:"/img/prims-algo.png",alt:"Prim\u2019s Algorithm Graph Input",width:"500"})}),"\n",(0,t.jsx)(e.p,{children:"We start with Node 0 and build the Minimum Spanning Tree (MST) by always picking the lowest-weight edge that connects a visited node to an unvisited one."}),"\n",(0,t.jsx)(e.p,{children:"Steps:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Start at Node 0\nLowest edge: 0 \u2192 4 (6) \u2192 Add to MST"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["From ",4,"\nLowest edge: 4 \u2192 3 (2) \u2192 Add to MST"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["From ",3,"\nLowest edge: 4 \u2192 2 (3) \u2192 Add to MST"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["From ",2,"\nLowest edge: 2 \u2192 1 (8) \u2192 Add to MST"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"All nodes are now connected with the minimum total weight."}),"\n",(0,t.jsx)("p",{align:"center",children:(0,t.jsx)("img",{src:"/img/prims-algo-mst.png",alt:"Prim\u2019s Algorithm MST Output",width:"500"})}),"\n",(0,t.jsxs)(e.p,{children:["The edges in ",(0,t.jsx)(e.strong,{children:"teal"})," form the ",(0,t.jsx)(e.strong,{children:"Minimum Spanning Tree"}),"."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"\ufe0f-go-implementation",children:"\ud83d\udee0\ufe0f Go Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n    "container/heap"\n    "fmt"\n)\n\ntype MinHeap [][]int\n\nfunc (h MinHeap) Len() int           { return len(h) }\nfunc (h MinHeap) Less(i, j int) bool { return h[i][2] < h[j][2] }\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *MinHeap) Push(value any)    { *h = append(*h, value.([]int)) }\nfunc (h *MinHeap) Pop() any {\n    l := len(*h)\n    val := (*h)[l-1]\n    *h = (*h)[:l-1]\n    return val\n}\n\nfunc printMst(edges [][][]int) [][][]int {\n    mst := make([][][]int, len(edges))\n    h := &MinHeap{}\n    heap.Init(h)\n\n    for _, edge := range edges[0] {\n        heap.Push(h, []int{0, edge[0], edge[1]}) // from, to, weight\n    }\n\n    visited := map[int]bool{0: true}\n\n    for h.Len() > 0 {\n        edge := heap.Pop(h).([]int)\n        from, to, weight := edge[0], edge[1], edge[2]\n\n        if visited[to] {\n            continue\n        }\n\n        visited[to] = true\n        mst[from] = append(mst[from], []int{to, weight})\n        mst[to] = append(mst[to], []int{from, weight})\n\n        for _, next := range edges[to] {\n            if !visited[next[0]] {\n                heap.Push(h, []int{to, next[0], next[1]})\n            }\n        }\n    }\n\n    return mst\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"sample-input",children:"Sample Input"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'func main() {\n    edges := [][][]int{\n        {{1, 12}, {4, 6}},        // Node 0\n        {{0, 12}, {2, 8}},        // Node 1\n        {{1, 8}, {3, 5}, {4, 3}}, // Node 2\n        {{2, 5}, {4, 2}},         // Node 3\n        {{0, 6}, {2, 3}, {3, 2}}, // Node 4\n    }\n\n    mst := printMst(edges)\n    fmt.Println("Minimum Spanning Tree:")\n    for i, connections := range mst {\n        for _, conn := range connections {\n            fmt.Printf("%d -- %d (weight %d)\\n", i, conn[0], conn[1])\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"output",children:"Output"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Minimum Spanning Tree:\n0 -- 4 (weight 6)\n1 -- 2 (weight 8)\n2 -- 4 (weight 3)\n2 -- 1 (weight 8)\n3 -- 4 (weight 2)\n4 -- 0 (weight 6)\n4 -- 3 (weight 2)\n4 -- 2 (weight 3)\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"\ufe0f-time--space-complexity",children:"\u23f1\ufe0f Time & Space Complexity"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": ",(0,t.jsx)(e.code,{children:"O(E log E)"})," due to min-heap operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": ",(0,t.jsx)(e.code,{children:"O(V + E)"})," for the heap and adjacency list"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-advantages",children:"\ud83d\udc4d Advantages"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Efficient for ",(0,t.jsx)(e.strong,{children:"dense graphs"})]}),"\n",(0,t.jsx)(e.li,{children:"Easy to implement with a min-heap"}),"\n",(0,t.jsx)(e.li,{children:"Builds MST without sorting all edges"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"-disadvantages",children:"\ud83d\udc4e Disadvantages"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Doesn\u2019t work on ",(0,t.jsx)(e.strong,{children:"directed graphs"})]}),"\n",(0,t.jsxs)(e.li,{children:["Fails on graphs with ",(0,t.jsx)(e.strong,{children:"negative weights"})]}),"\n",(0,t.jsxs)(e.li,{children:["Requires the graph to be ",(0,t.jsx)(e.strong,{children:"connected"})]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Prim\u2019s Algorithm is a powerful tool for finding MSTs in undirected graphs. It\u2019s highly practical for infrastructure design, network planning, and clustering algorithms."}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["\ud83e\udde0 Remember: Use Prim\u2019s when the graph is ",(0,t.jsx)(e.strong,{children:"undirected"}),", ",(0,t.jsx)(e.strong,{children:"connected"}),", and all weights are ",(0,t.jsx)(e.strong,{children:"non-negative"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:["Feel free to follow my work on GitHub: ",(0,t.jsx)(e.a,{href:"https://github.com/shekhar-patil/data_structure_and_algorithms/blob/main/graph_algorithms/prims_algorithm.go",children:"Prim's Algorithm in Go"}),"."]})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function l(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);